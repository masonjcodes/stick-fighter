<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medieval Stick Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: auto;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .main-menu {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            text-align: center;
            color: white;
            min-width: 400px;
        }
        
        .main-menu h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .menu-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
            min-width: 200px;
        }
        
        .menu-button:hover {
            transform: scale(1.05);
        }
        
        .map-selection {
            margin-top: 20px;
        }
        
        .map-option {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .map-option:hover {
            background: rgba(0, 0, 0, 0.5);
        }
        
        .map-option.selected {
            background: rgba(100, 126, 234, 0.5);
            border: 2px solid #667eea;
        }

        .color-option {
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            min-width: 120px;
            text-align: center;
        }

        .color-option:hover {
            transform: scale(1.1);
        }
        
        .map-name {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 5px;
        }
        
        .map-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #003366 100%);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        .player-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 200px;
        }

        .player1 {
            background: rgba(255, 0, 0, 0.3);
        }

        .player2 {
            background: rgba(0, 0, 255, 0.3);
        }

        .player3 {
            background: rgba(0, 255, 0, 0.3);
        }

        .player4 {
            background: rgba(101, 67, 33, 0.5);
        }

        .health-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .control-section {
            text-align: center;
        }

        .control-section h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 10;
        }

        .game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .restart-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        .weapon-indicator {
            font-size: 14px;
            color: #FFD700;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="main-menu" id="mainMenu">
        <h1>Medieval Stick Fighter</h1>
        <div class="player-selection" id="playerSelection">
            <h3>Select Number of Players:</h3>
            <button class="menu-button" onclick="selectPlayerCount(1)">1 Player</button>
            <button class="menu-button" onclick="selectPlayerCount(2)">2 Players</button>
            <button class="menu-button" onclick="selectPlayerCount(3)">3 Players</button>
        </div>
        <div class="ai-selection" id="aiSelection" style="display: none;">
            <h3>Add AI Opponent?</h3>
            <button class="menu-button" onclick="addAI(true)">Add AI</button>
            <button class="menu-button" onclick="addAI(false)">No AI</button>
        </div>
        <div class="color-selection" id="colorSelection" style="display: none;">
            <h3>Choose Your Color:</h3>
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <div class="color-option" onclick="selectColor('red')" style="background: rgba(220, 20, 60, 0.5);">
                    <div style="color: #dc143c; font-size: 24px; margin-bottom: 10px;">Red</div>
                    <div style="color: white; font-size: 14px;">Fire Magic</div>
                </div>
                <div class="color-option" onclick="selectColor('blue')" style="background: rgba(0, 0, 255, 0.5);">
                    <div style="color: #0000ff; font-size: 24px; margin-bottom: 10px;">Blue</div>
                    <div style="color: white; font-size: 14px;">Ice Magic</div>
                </div>
                <div class="color-option" onclick="selectColor('green')" style="background: rgba(34, 139, 34, 0.5);">
                    <div style="color: #228B22; font-size: 24px; margin-bottom: 10px;">Green</div>
                    <div style="color: white; font-size: 14px;">Earth Magic</div>
                </div>
                <div class="color-option" onclick="selectColor('brown')" style="background: rgba(101, 67, 33, 0.5);">
                    <div style="color: #654321; font-size: 24px; margin-bottom: 10px;">Brown</div>
                    <div style="color: white; font-size: 14px;">Dark Magic</div>
                </div>
            </div>
        </div>
        <div class="map-selection" style="display: none;" id="mapSelection">
            <h3>Select Map:</h3>
            <div class="map-option selected" onclick="selectMap('classic')" id="map-classic">
                <div class="map-name">Classic Arena</div>
                <div class="map-description">Simple flat ground for pure combat</div>
            </div>
            <div class="map-option" onclick="selectMap('platform')" id="map-platform">
                <div class="map-name">Platform Battle</div>
                <div class="map-description">Fight with a platform in the middle for strategic advantage</div>
            </div>
            <div class="map-option" onclick="selectMap('skylands')" id="map-skylands">
                <div class="map-name">Sky Islands</div>
                <div class="map-description">Battle across floating cloud platforms high in the sky</div>
            </div>
        </div>
        <button class="menu-button" onclick="startGame()">Start Game</button>
    </div>
    
    <div class="game-container" id="gameContainer">
        <div class="game-info">
            <div class="player-info player1">
                <div id="player1">Player 1</div>
                <div class="health-bar">
                    <div class="health-fill" id="health1"></div>
                </div>
                <div class="weapon-indicator" id="weapon1">Sword</div>
            </div>
            <div class="player-info player2">
                <div id="player2">Player 2</div>
                <div class="health-bar">
                    <div class="health-fill" id="health2"></div>
                </div>
                <div class="weapon-indicator" id="weapon2">Sword</div>
            </div>
            <div class="player-info player3" id="player3Info" style="display: none;">
                <div id="player3">Player 3</div>
                <div class="health-bar">
                    <div class="health-fill" id="health3"></div>
                </div>
                <div class="weapon-indicator" id="weapon3">Sword</div>
            </div>
            <div class="player-info player4" id="player4Info" style="display: none;">
                <div id="player4">Player 4</div>
                <div class="health-bar">
                    <div class="health-fill" id="health4"></div>
                </div>
                <div class="weapon-indicator" id="weapon4">Sword</div>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="500"></canvas>
        <div class="controls">
            <div class="control-section">
                <h3>Player 1 (Red)</h3>
                <div><span class="key">W</span> Jump</div>
                <div><span class="key">A</span> <span class="key">D</span> Move</div>
                <div><span class="key">S</span> Attack</div>
                <div><span class="key">Q</span> Switch Weapon</div>
                <div><span class="key">E</span> Hold to Aim Bow</div>
                <div><span class="key">E+Q</span> Fire Blast</div>
            </div>
            <div class="control-section">
                <h3>Player 2 (Blue)</h3>
                <div><span class="key">↑</span> Jump</div>
                <div><span class="key">←</span> <span class="key">→</span> Move</div>
                <div><span class="key">↓</span> Attack</div>
                <div><span class="key">/</span> Switch Weapon</div>
                <div><span class="key">.</span> Hold to Aim Bow</div>
                <div><span class="key">.+/</span> Ice Blast</div>
            </div>
            <div class="control-section" id="player3Controls" style="display: none;">
                <h3>Player 3 (Green)</h3>
                <div><span class="key">I</span> Jump</div>
                <div><span class="key">J</span> <span class="key">L</span> Move</div>
                <div><span class="key">K</span> Attack</div>
                <div><span class="key">U</span> Switch Weapon</div>
                <div><span class="key">O</span> Hold to Aim Bow</div>
                <div><span class="key">O+U</span> Earth Blast</div>
            </div>
            <div class="control-section" id="player4Controls" style="display: none;">
                <h3>Player 4 (Brown)</h3>
                <div>AI Controlled</div>
                <div>Automatically fights</div>
                <div>Casts Dark Magic</div>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="winnerText">Player 1 Wins!</h2>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
        <button class="restart-btn" onclick="backToMenu()">Main Menu</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let groundY = canvas.height - 50;
        let currentMap = 'classic';
        let platforms = [];
        let playerCount = 2;
        let player3 = null;
        let player4 = null;
        let hasAI = false;
        let humanPlayerCount = 2;
        let playerColors = [];
        let lastInputTime = 0;
        let colorMap = {
            'red': { color: '#dc143c', magic: 'fire' },
            'blue': { color: '#0000ff', magic: 'ice' },
            'green': { color: '#228B22', magic: 'earth' },
            'brown': { color: '#654321', magic: 'dark' }
        };
        
        // Platform class for platform maps
        class Platform {
            constructor(x, y, width, height, isCloud = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isCloud = isCloud;
            }
            
            draw() {
                if (this.isCloud) {
                    // Draw cloud platform
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    // Draw cloud shape
                    const bumps = Math.floor(this.width / 30);
                    for (let i = 0; i < bumps; i++) {
                        ctx.arc(this.x + (i * 30) + 15, this.y + 10, 15, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                } else {
                    // Draw regular platform
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(this.x, this.y, this.width, 5);
                }
            }
            
            checkCollision(player) {
                if (player.x + player.width > this.x &&
                    player.x < this.x + this.width &&
                    player.y + player.height >= this.y - 5 &&
                    player.y + player.height <= this.y + 20 &&
                    player.velocityY >= -0.5) {
                    player.y = this.y - player.height;
                    player.velocityY = 0;
                    player.onGround = true;
                    return true;
                }
                return false;
            }
        }

        // Weapon types
        const weapons = {
            sword: { damage: 15, range: 60, speed: 5, cooldown: 500 },
            axe: { damage: 25, range: 50, speed: 3, cooldown: 800 },
            spear: { damage: 10, range: 80, speed: 7, cooldown: 400 },
            mace: { damage: 20, range: 40, speed: 4, cooldown: 600 }
        };
        
        // Bow settings (separate from main weapons)
        const bowSettings = { damage: 12, cooldown: 1000 };

        // Magic settings
        const magicSettings = { damage: 20, cooldown: 1500, speed: 10 };

        const weaponNames = Object.keys(weapons);
        
        // Projectile arrays
        const projectiles = [];
        const magicBlasts = [];

        // Earthquake state
        let earthquakeActive = false;
        let earthquakeTimer = 0;
        let earthquakeCaster = null;
        let screenShake = 0;
        
        // Hit effects array
        const hitEffects = [];
        
        // Hit effect class
        class HitEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = 30;
                this.opacity = 1;
                this.active = true;
                this.particles = [];
                
                // Create particles
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(i * Math.PI / 4) * 5,
                        vy: Math.sin(i * Math.PI / 4) * 5 - 2,
                        size: Math.random() * 3 + 2
                    });
                }
            }
            
            update() {
                this.radius += 2;
                this.opacity -= 0.05;
                
                // Update particles
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3;
                    p.vx *= 0.95;
                    p.size *= 0.95;
                });
                
                if (this.opacity <= 0) {
                    this.active = false;
                }
            }
            
            draw() {
                ctx.save();
                
                // Draw impact circle
                ctx.strokeStyle = `rgba(255, 255, 0, ${this.opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw particles
                ctx.fillStyle = `rgba(255, 100, 0, ${this.opacity})`;
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        
        function createHitEffect(x, y) {
            hitEffects.push(new HitEffect(x, y));
        }
        
        function drawTargetingLine(shooter, target) {
            ctx.save();
            
            // Calculate trajectory
            const startX = shooter.x + shooter.width/2;
            const startY = shooter.y + 40;
            const targetX = target.x + target.width/2;
            const targetY = target.y + target.height/2;
            
            // Draw targeting line
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Draw curved trajectory preview
            const steps = 20;
            const dx = (targetX - startX) / steps;
            const dy = (targetY - startY) / steps;
            
            for (let i = 1; i <= steps; i++) {
                const x = startX + dx * i;
                const baseY = startY + dy * i;
                // Add parabolic curve to show arrow trajectory
                const curveOffset = Math.sin((i / steps) * Math.PI) * -30;
                const y = baseY + curveOffset;
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw target crosshair
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(targetX, targetY, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw crosshair lines
            ctx.beginPath();
            ctx.moveTo(targetX - 20, targetY);
            ctx.lineTo(targetX + 20, targetY);
            ctx.moveTo(targetX, targetY - 20);
            ctx.lineTo(targetX, targetY + 20);
            ctx.stroke();
            
            // Draw power indicator
            const power = Math.min(1, shooter.bowCooldown > 0 ? 0 : 1);
            ctx.fillStyle = power === 1 ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 255, 0, 0.5)';
            ctx.fillRect(startX - 20, startY - 40, 40 * power, 5);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.strokeRect(startX - 20, startY - 40, 40, 5);
            
            ctx.restore();
        }
        
        // Magic Blast class
        class MagicBlast {
            constructor(x, y, direction, owner, type, target = null) {
                this.x = x;
                this.y = y;
                this.velocityX = direction * magicSettings.speed;
                this.velocityY = 0;
                this.width = 30;
                this.height = 30;
                this.owner = owner;
                this.damage = magicSettings.damage;
                this.type = type; // 'fire', 'ice', 'earth', 'dark'
                this.active = true;
                this.rotation = 0;
                this.particles = [];
                this.lifetime = 100;
                this.target = target;
                this.hasHit = false; // Track if spike has hit someone

                // Earth no longer creates projectiles (uses earthquake instead)
            }

            update() {
                // Heat-seeking for fire, ice, and dark (earth no longer uses projectiles)
                if ((this.type === 'fire' || this.type === 'ice' || this.type === 'dark') && this.target && this.target.health > 0) {
                    const dx = (this.target.x + this.target.width/2) - this.x;
                    const dy = (this.target.y + this.target.height/2) - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        // Adjust velocity to track target
                        const trackingSpeed = 0.15; // How aggressively it tracks
                        this.velocityX += (dx / distance) * trackingSpeed * magicSettings.speed;
                        this.velocityY += (dy / distance) * trackingSpeed * magicSettings.speed;

                        // Limit max speed
                        const currentSpeed = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
                        if (currentSpeed > magicSettings.speed * 1.5) {
                            this.velocityX = (this.velocityX / currentSpeed) * magicSettings.speed * 1.5;
                            this.velocityY = (this.velocityY / currentSpeed) * magicSettings.speed * 1.5;
                        }
                    }
                }

                this.x += this.velocityX;
                this.y += this.velocityY;

                this.rotation += 0.2;
                this.lifetime--;

                // Create particle trail
                if (Math.random() < 0.8) {
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 20,
                        size: Math.random() * 5 + 3
                    });
                }

                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.95;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Remove if out of bounds or lifetime expired
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y > groundY || this.lifetime <= 0) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();

                // Draw particles first (trail effect)
                this.particles.forEach(p => {
                    const alpha = p.life / 20;
                    switch(this.type) {
                        case 'fire':
                            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha})`;
                            break;
                        case 'ice':
                            ctx.fillStyle = `rgba(100, 200, 255, ${alpha})`;
                            break;
                        case 'earth':
                            ctx.fillStyle = `rgba(139, 90, 43, ${alpha})`;
                            break;
                        case 'dark':
                            ctx.fillStyle = `rgba(75, 0, 130, ${alpha})`;
                            break;
                    }
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw main blast
                ctx.translate(this.x, this.y);

                ctx.rotate(this.rotation);

                // Glow effect
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                switch(this.type) {
                    case 'fire':
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0.2)');
                        break;
                    case 'ice':
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(0, 100, 200, 0.2)');
                        break;
                    case 'earth':
                        gradient.addColorStop(0, 'rgba(255, 220, 100, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(139, 90, 43, 0.6)');
                        gradient.addColorStop(1, 'rgba(101, 67, 33, 0.2)');
                        break;
                    case 'dark':
                        gradient.addColorStop(0, 'rgba(150, 0, 255, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(75, 0, 130, 0.6)');
                        gradient.addColorStop(1, 'rgba(25, 0, 50, 0.2)');
                        break;
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();

                // Inner core
                switch(this.type) {
                    case 'fire':
                        ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
                        break;
                    case 'ice':
                        ctx.fillStyle = 'rgba(200, 230, 255, 0.9)';
                        break;
                    case 'earth':
                        ctx.fillStyle = 'rgba(180, 140, 80, 0.9)';
                        break;
                    case 'dark':
                        ctx.fillStyle = 'rgba(50, 0, 100, 0.9)';
                        break;
                }
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, direction, owner, damage) {
                this.x = x;
                this.y = y;
                this.velocityX = direction * 15;
                this.velocityY = -2;
                this.width = 20;
                this.height = 4;
                this.owner = owner;
                this.damage = damage;
                this.active = true;
            }
            
            update() {
                this.x += this.velocityX;
                this.velocityY += 0.25; // gravity (balanced)
                this.y += this.velocityY;
                
                // Remove if out of bounds
                if (this.x < -50 || this.x > canvas.width + 50 || this.y > groundY) {
                    this.active = false;
                }
            }
            
            draw() {
                ctx.save();
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                // Arrow shaft
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.velocityX * 0.8, this.y - this.velocityY * 0.8);
                ctx.stroke();
                
                // Arrowhead
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - 8 * Math.sign(this.velocityX), this.y - 3);
                ctx.lineTo(this.x - 8 * Math.sign(this.velocityX), this.y + 3);
                ctx.closePath();
                ctx.fill();
                
                // Feathers
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.velocityX * 0.8, this.y - this.velocityY * 0.8);
                ctx.lineTo(this.x - this.velocityX * 0.8 - 3, this.y - this.velocityY * 0.8 - 3);
                ctx.moveTo(this.x - this.velocityX * 0.8, this.y - this.velocityY * 0.8);
                ctx.lineTo(this.x - this.velocityX * 0.8 - 3, this.y - this.velocityY * 0.8 + 3);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor(x, color, controls) {
                this.x = x;
                this.y = groundY - 100;
                this.width = 30;
                this.height = 100;
                this.color = color;
                this.health = 100;
                this.maxHealth = 100;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5.5;
                this.jumpPower = 15;
                this.onGround = false;
                this.controls = controls;
                this.facing = 1; // 1 for right, -1 for left
                this.attacking = false;
                this.attackCooldown = 0;
                this.currentWeaponIndex = 0;
                this.currentWeapon = weaponNames[0];
                this.attackAngle = 0;
                this.blocking = false;
                this.stunned = false;
                this.stunTimer = 0;
                this.hitConfirmed = false;
                this.bowCooldown = 0;
                this.slowed = false;
                this.slowTimer = 0;
                this.burning = false;
                this.burnTimer = 0;
                this.burnDamageTimer = 0;
                this.lastDarkCastTime = 0;
                this.darkMagicStreak = 0;
                this.walkCycle = 0;
                this.isMoving = false;
                this.isAiming = false;
                this.magicCooldown = 0;
                this.magicElement = 'fire'; // default, will be set per player
            }

            update() {
                // Don't update if dead
                if (this.health <= 0) {
                    this.velocityX = 0;
                    this.attacking = false;
                    this.isAiming = false;
                    // Still apply gravity so dead players fall to ground
                    if (!this.onGround) {
                        this.velocityY += 0.65;
                    }
                    this.y += this.velocityY;
                    // Ground collision for dead players
                    if (this.y + this.height >= groundY) {
                        this.y = groundY - this.height;
                        this.velocityY = 0;
                        this.onGround = true;
                    }
                    return;
                }

                // Apply gravity (balanced for good jump feel)
                if (!this.onGround) {
                    this.velocityY += 0.65;
                }

                // Update stun
                if (this.stunned) {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) {
                        this.stunned = false;
                    }
                }

                // Update slow effect
                if (this.slowed) {
                    this.slowTimer--;
                    if (this.slowTimer <= 0) {
                        this.slowed = false;
                    }
                }

                // Update burn effect
                if (this.burning) {
                    this.burnTimer--;
                    this.burnDamageTimer++;

                    // Take burn damage every 20 frames
                    if (this.burnDamageTimer >= 20) {
                        this.takeDamage(3, true); // 3 damage per tick, bypass stun
                        this.burnDamageTimer = 0;
                    }

                    if (this.burnTimer <= 0) {
                        this.burning = false;
                        this.burnDamageTimer = 0;
                    }
                }

                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Platform and ground collision
                let onPlatform = false;
                let wasOnGround = this.onGround;
                
                // Check platform collisions
                for (let platform of platforms) {
                    if (platform.checkCollision(this)) {
                        onPlatform = true;
                        break;
                    }
                }
                
                // Check ground collision
                if (!onPlatform) {
                    if (this.y + this.height >= groundY) {
                        this.y = groundY - this.height;
                        this.velocityY = 0;
                        this.onGround = true;
                    } else {
                        // Only set onGround to false if we're clearly in the air
                        if (this.y + this.height < groundY - 5) {
                            let stillOnPlatform = false;
                            for (let platform of platforms) {
                                if (this.x + this.width > platform.x &&
                                    this.x < platform.x + platform.width &&
                                    Math.abs(this.y + this.height - platform.y) < 5) {
                                    stillOnPlatform = true;
                                    break;
                                }
                            }
                            if (!stillOnPlatform) {
                                this.onGround = false;
                            }
                        }
                    }
                }

                // Wall collision
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Friction
                this.velocityX *= 0.85;

                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }

                // Update attack animation
                if (this.attacking) {
                    this.attackAngle += 0.3;
                    if (this.attackAngle > Math.PI) {
                        this.attacking = false;
                        this.attackAngle = 0;
                        this.hitConfirmed = false;
                    }
                }
                
                // Update bow cooldown
                if (this.bowCooldown > 0) {
                    this.bowCooldown--;
                }

                // Update magic cooldown
                if (this.magicCooldown > 0) {
                    this.magicCooldown--;
                }
                
                // Update walk animation
                this.isMoving = Math.abs(this.velocityX) > 0.5;
                if (this.isMoving) {
                    this.walkCycle += 0.18;
                }
            }

            draw() {
                ctx.save();

                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.x + this.width/2, groundY, this.width/2, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw stick figure body
                const opacity = this.health <= 0 ? 0.3 : 1;
                ctx.globalAlpha = opacity;

                // Change color based on status
                let drawColor = this.color;
                if (this.stunned) {
                    drawColor = 'gray';
                } else if (this.slowed) {
                    drawColor = '#87CEEB'; // Light blue tint when slowed
                }

                // Draw burn effect
                if (this.burning) {
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.strokeStyle = drawColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                // Head
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + 20, 15, 0, Math.PI * 2);
                ctx.stroke();

                // Body
                ctx.beginPath();
                ctx.moveTo(this.x + this.width/2, this.y + 35);
                ctx.lineTo(this.x + this.width/2, this.y + 70);
                ctx.stroke();

                // Arms
                if (this.attacking) {
                    // Attacking arm animation
                    let armAngle = -this.attackAngle * this.facing;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + 40);
                    ctx.lineTo(
                        this.x + this.width/2 + Math.cos(armAngle) * 30 * this.facing,
                        this.y + 40 + Math.sin(armAngle) * 30
                    );
                    ctx.stroke();

                    // Draw weapon
                    this.drawWeapon(
                        this.x + this.width/2 + Math.cos(armAngle) * 30 * this.facing,
                        this.y + 40 + Math.sin(armAngle) * 30,
                        armAngle
                    );
                } else {
                    // Animated arms based on movement state
                    if (!this.onGround) {
                        // Arms up when jumping
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 - 15, this.y + 20);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 + 15, this.y + 20);
                        ctx.stroke();
                    } else if (this.isMoving) {
                        // Swaying arms when walking (opposite to legs)
                        const armSwing = Math.sin(this.walkCycle + Math.PI) * 15;
                        const armSwing2 = Math.sin(this.walkCycle) * 15;
                        
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 - 20 + armSwing, this.y + 60);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 + 20 + armSwing2, this.y + 60);
                        ctx.stroke();
                    } else {
                        // Normal resting arms
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 - 20, this.y + 60);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y + 40);
                        ctx.lineTo(this.x + this.width/2 + 20, this.y + 60);
                        ctx.stroke();
                    }
                }

                // Legs with walking animation
                const legOffset = this.isMoving ? Math.sin(this.walkCycle) * 10 : 0;
                const legOffset2 = this.isMoving ? Math.sin(this.walkCycle + Math.PI) * 10 : 0;
                
                ctx.beginPath();
                ctx.moveTo(this.x + this.width/2, this.y + 70);
                ctx.lineTo(this.x + this.width/2 - 15 + legOffset, this.y + this.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.x + this.width/2, this.y + 70);
                ctx.lineTo(this.x + this.width/2 + 15 + legOffset2, this.y + this.height);
                ctx.stroke();

                ctx.restore();
            }

            drawWeapon(x, y, angle) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 5;

                const weapon = weapons[this.currentWeapon];

                switch(this.currentWeapon) {
                    case 'sword':
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(weapon.range * this.facing, 0);
                        ctx.stroke();
                        // Sword guard
                        ctx.strokeStyle = '#696969';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(10 * this.facing, -5);
                        ctx.lineTo(10 * this.facing, 5);
                        ctx.stroke();
                        break;
                    case 'axe':
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(weapon.range * this.facing, 0);
                        ctx.stroke();
                        // Axe head
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.moveTo(weapon.range * this.facing, 0);
                        ctx.lineTo((weapon.range - 10) * this.facing, -10);
                        ctx.lineTo((weapon.range - 10) * this.facing, 10);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'spear':
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(weapon.range * this.facing, 0);
                        ctx.stroke();
                        // Spear tip
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.moveTo(weapon.range * this.facing, 0);
                        ctx.lineTo((weapon.range - 15) * this.facing, -5);
                        ctx.lineTo((weapon.range - 15) * this.facing, 5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'mace':
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(weapon.range * this.facing, 0);
                        ctx.stroke();
                        // Mace head
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(weapon.range * this.facing, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }

                ctx.restore();
            }
            
            shootBow(target) {
                if (this.bowCooldown > 0 || this.health <= 0) return;
                
                // Calculate direction to target
                const dx = (target.x + target.width/2) - (this.x + this.width/2);
                const dy = (target.y + target.height/2) - (this.y + this.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate velocity to hit target
                const speed = 12;
                const vx = (dx / distance) * speed;
                const vy = (dy / distance) * speed - 3; // Compensate for gravity
                
                const arrow = new Projectile(
                    this.x + this.width/2,
                    this.y + 40,
                    Math.sign(dx),
                    this,
                    bowSettings.damage
                );
                arrow.velocityX = vx;
                arrow.velocityY = vy;
                projectiles.push(arrow);
                
                this.bowCooldown = bowSettings.cooldown / 10;
            }

            castMagic(direction) {
                // Dark magic has no cooldown but always self-damages
                if (this.magicElement !== 'dark' && this.magicCooldown > 0) return;
                if (this.health <= 0) return;

                // Dark magic always causes self-damage
                if (this.magicElement === 'dark') {
                    this.takeDamage(10, true); // 10 self-damage every cast
                    createHitEffect(this.x + this.width/2, this.y + this.height/2);
                }

                // Earth magic triggers earthquake instead of projectile
                if (this.magicElement === 'earth') {
                    if (!earthquakeActive) {
                        earthquakeActive = true;
                        earthquakeTimer = 90; // 1.5 seconds at 60fps
                        earthquakeCaster = this;
                        screenShake = 10;
                    }
                    this.magicCooldown = magicSettings.cooldown / 10;
                    return; // Don't create a projectile
                }

                // Find nearest target for heat-seeking/earth spike
                let target = null;
                if (this.magicElement === 'fire' || this.magicElement === 'ice' ||
                    this.magicElement === 'dark' || this.magicElement === 'earth') {
                    const players = [player1, player2];
                    if (playerCount >= 3 && player3) players.push(player3);
                    if (playerCount === 4 && player4) players.push(player4);

                    let minDistance = Infinity;
                    for (const p of players) {
                        if (p !== this && p.health > 0) {
                            const dist = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
                            if (dist < minDistance) {
                                minDistance = dist;
                                target = p;
                            }
                        }
                    }
                }

                const blast = new MagicBlast(
                    this.x + this.width/2,
                    this.y + 40,
                    direction || this.facing,
                    this,
                    this.magicElement,
                    target
                );
                magicBlasts.push(blast);

                // Dark magic has no cooldown
                if (this.magicElement !== 'dark') {
                    this.magicCooldown = magicSettings.cooldown / 10;
                }
            }

            jump() {
                if (this.onGround && !this.stunned && this.health > 0) {
                    this.velocityY = -this.jumpPower;
                }
            }

            moveLeft() {
                if (!this.stunned && this.health > 0) {
                    const speedMod = this.slowed ? 0.5 : 1;
                    this.velocityX = -this.speed * speedMod;
                    this.facing = -1;
                }
            }

            moveRight() {
                if (!this.stunned && this.health > 0) {
                    const speedMod = this.slowed ? 0.5 : 1;
                    this.velocityX = this.speed * speedMod;
                    this.facing = 1;
                }
            }

            attack() {
                if (this.attackCooldown === 0 && !this.attacking && !this.stunned && this.health > 0) {
                    this.attacking = true;
                    this.attackCooldown = weapons[this.currentWeapon].cooldown / 10;
                }
            }

            switchWeapon() {
                this.currentWeaponIndex = (this.currentWeaponIndex + 1) % weaponNames.length;
                this.currentWeapon = weaponNames[this.currentWeaponIndex];
            }

            takeDamage(damage, bypassStun = false) {
                this.health -= damage;
                if (this.health < 0) this.health = 0;
                if (!bypassStun) {
                    this.stunned = true;
                    this.stunTimer = 10;
                    // Knockback
                    this.velocityX = -this.facing * 5;
                    this.velocityY = -5;
                }
            }

            getWeaponHitbox() {
                if (!this.attacking) return null;
                const weapon = weapons[this.currentWeapon];
                
                // Calculate weapon position based on attack angle
                const armLength = 30;
                const armAngle = -this.attackAngle * this.facing;
                const weaponStartX = this.x + this.width/2 + Math.cos(armAngle) * armLength * this.facing;
                const weaponStartY = this.y + 40 + Math.sin(armAngle) * armLength;
                const weaponEndX = weaponStartX + Math.cos(armAngle) * weapon.range * this.facing;
                const weaponEndY = weaponStartY + Math.sin(armAngle) * weapon.range;
                
                // Create hitbox around weapon line
                const minX = Math.min(weaponStartX, weaponEndX);
                const maxX = Math.max(weaponStartX, weaponEndX);
                const minY = Math.min(weaponStartY, weaponEndY) - 10;
                const maxY = Math.max(weaponStartY, weaponEndY) + 10;
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
        }

        // Create players
        const player1 = new Player(200, '#dc143c', {
            jump: 'w',
            left: 'a',
            right: 'd',
            attack: 's',
            switchWeapon: 'q',
            bow: 'e'
        });
        player1.magicElement = 'fire';

        const player2 = new Player(800, '#0000ff', {
            jump: 'ArrowUp',
            left: 'ArrowLeft',
            right: 'ArrowRight',
            attack: 'ArrowDown',
            switchWeapon: '/',
            bow: '.'
        });
        player2.magicElement = 'ice';

        // Player 3 and 4 will be created when their modes are selected

        // Input handling
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            lastInputTime = Date.now(); // Track when human input happens
            
            // Weapon switching (only for non-AI players)
            if (!player1.isAI && e.key.toLowerCase() === player1.controls.switchWeapon) {
                player1.switchWeapon();
                document.getElementById('weapon1').textContent =
                    player1.currentWeapon.charAt(0).toUpperCase() + player1.currentWeapon.slice(1);
            }
            if (!player2.isAI && e.key === player2.controls.switchWeapon) {
                player2.switchWeapon();
                document.getElementById('weapon2').textContent =
                    player2.currentWeapon.charAt(0).toUpperCase() + player2.currentWeapon.slice(1);
            }
            if (playerCount >= 3 && player3 && !player3.isAI && e.key.toLowerCase() === player3.controls.switchWeapon) {
                player3.switchWeapon();
                document.getElementById('weapon3').textContent =
                    player3.currentWeapon.charAt(0).toUpperCase() + player3.currentWeapon.slice(1);
            }

            // Magic casting (hold bow key + press switch weapon key) - only for non-AI
            if (!player1.isAI && keys[player1.controls.bow] && e.key.toLowerCase() === player1.controls.switchWeapon) {
                player1.castMagic();
            }
            if (!player2.isAI && keys[player2.controls.bow] && e.key === player2.controls.switchWeapon) {
                player2.castMagic();
            }
            if (playerCount >= 3 && player3 && !player3.isAI && keys[player3.controls.bow] && e.key.toLowerCase() === player3.controls.switchWeapon) {
                player3.castMagic();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function getNearestTarget(shooter) {
            const players = [player1, player2];
            if (playerCount >= 3 && player3) players.push(player3);
            if (playerCount === 4 && player4) players.push(player4);

            let nearestTarget = null;
            let minDistance = Infinity;

            for (const player of players) {
                if (player === shooter || player.health <= 0) continue;

                const dx = player.x - shooter.x;
                const dy = player.y - shooter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTarget = player;
                }
            }

            return nearestTarget;
        }

        function updateAI() {
            // Check all players for AI
            const aiPlayers = [];
            if (player1 && player1.isAI) aiPlayers.push(player1);
            if (player2 && player2.isAI) aiPlayers.push(player2);
            if (player3 && player3.isAI) aiPlayers.push(player3);
            if (player4 && player4.isAI) aiPlayers.push(player4);

            aiPlayers.forEach(aiPlayer => {
                if (aiPlayer.health <= 0) return;

                const target = getNearestTarget(aiPlayer);
                if (!target) return;

                const dx = target.x - aiPlayer.x;
                const dy = target.y - aiPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Movement AI
                if (distance > 100) {
                    // Move towards nearest enemy
                    if (dx > 10) {
                        aiPlayer.moveRight();
                    } else if (dx < -10) {
                        aiPlayer.moveLeft();
                    }
                }

                // Jump if target is above
                if (dy < -50 && aiPlayer.onGround && Math.random() < 0.1) {
                    aiPlayer.jump();
                }

                // Combat AI
                if (distance < 80) {
                    // Attack when close
                    if (Math.random() < 0.15) {
                        aiPlayer.attack();
                    }
                } else if (distance < 300 && distance > 150) {
                    // Use bow at medium range
                    if (aiPlayer.bowCooldown <= 0 && Math.random() < 0.05) {
                        aiPlayer.shootBow(target);
                    }
                }

                // Randomly switch weapons
                if (Math.random() < 0.005) {
                    aiPlayer.switchWeapon();
                    // Update weapon display for the right AI player
                    if (aiPlayer === player1) {
                        document.getElementById('weapon1').textContent =
                            aiPlayer.currentWeapon.charAt(0).toUpperCase() + aiPlayer.currentWeapon.slice(1);
                    } else if (aiPlayer === player2) {
                        document.getElementById('weapon2').textContent =
                            aiPlayer.currentWeapon.charAt(0).toUpperCase() + aiPlayer.currentWeapon.slice(1);
                    } else if (aiPlayer === player3) {
                        document.getElementById('weapon3').textContent =
                            aiPlayer.currentWeapon.charAt(0).toUpperCase() + aiPlayer.currentWeapon.slice(1);
                    } else if (aiPlayer === player4) {
                        document.getElementById('weapon4').textContent =
                            aiPlayer.currentWeapon.charAt(0).toUpperCase() + aiPlayer.currentWeapon.slice(1);
                    }
                }

                // Occasionally cast magic (more often for dark magic since no cooldown)
                const magicChance = aiPlayer.magicElement === 'dark' ? 0.02 : 0.01;
                if (Math.random() < magicChance && (aiPlayer.magicElement === 'dark' || aiPlayer.magicCooldown <= 0)) {
                    aiPlayer.castMagic();
                }
            });
        }

        function handleInput() {
            // Player 1 controls (only if not AI)
            if (!player1.isAI) {
                if (keys[player1.controls.jump]) player1.jump();
                if (keys[player1.controls.left]) player1.moveLeft();
                if (keys[player1.controls.right]) player1.moveRight();
                if (keys[player1.controls.attack]) player1.attack();
            
                // Handle bow for player 1
                if (keys[player1.controls.bow]) {
                    if (!player1.isAiming) {
                        player1.isAiming = true;
                    }
                } else if (player1.isAiming) {
                    const target = getNearestTarget(player1);
                    if (target) player1.shootBow(target);
                    player1.isAiming = false;
                }
            }

            // Player 2 controls (only if not AI)
            if (!player2.isAI) {
                if (keys[player2.controls.jump.toLowerCase()]) player2.jump();
                if (keys[player2.controls.left.toLowerCase()]) player2.moveLeft();
                if (keys[player2.controls.right.toLowerCase()]) player2.moveRight();
                if (keys[player2.controls.attack.toLowerCase()]) player2.attack();
            
                // Handle bow for player 2
                if (keys[player2.controls.bow]) {
                    if (!player2.isAiming) {
                        player2.isAiming = true;
                    }
                } else if (player2.isAiming) {
                    const target = getNearestTarget(player2);
                    if (target) player2.shootBow(target);
                    player2.isAiming = false;
                }
            }

            // Player 3 controls (if active and not AI)
            if (playerCount >= 3 && player3 && !player3.isAI) {
                if (keys[player3.controls.jump]) player3.jump();
                if (keys[player3.controls.left]) player3.moveLeft();
                if (keys[player3.controls.right]) player3.moveRight();
                if (keys[player3.controls.attack]) player3.attack();

                // Handle bow for player 3
                if (keys[player3.controls.bow]) {
                    if (!player3.isAiming) {
                        player3.isAiming = true;
                    }
                } else if (player3.isAiming) {
                    const target = getNearestTarget(player3);
                    if (target) player3.shootBow(target);
                    player3.isAiming = false;
                }
            }
        }

        function checkCollisions() {
            const players = [player1, player2];
            if (playerCount >= 3 && player3) players.push(player3);
            if (playerCount === 4 && player4) players.push(player4);

            // Check weapon collisions for all players
            for (let i = 0; i < players.length; i++) {
                const attacker = players[i];
                if (attacker.attacking) {
                    const hitbox = attacker.getWeaponHitbox();
                    if (hitbox && !attacker.hitConfirmed) {
                        for (let j = 0; j < players.length; j++) {
                            if (i !== j) {
                                const target = players[j];
                                if (checkHit(hitbox, target)) {
                                    target.takeDamage(weapons[attacker.currentWeapon].damage);
                                    attacker.hitConfirmed = true;
                                    createHitEffect(target.x + target.width/2, target.y + target.height/2);
                                    break; // Only hit one target per attack
                                }
                            }
                        }
                    }
                }
            }
            
            // Check projectile collisions
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                // Check collision with all players except owner
                for (const player of players) {
                    if (player !== proj.owner) {
                        if (checkProjectileHit(proj, player)) {
                            player.takeDamage(proj.damage);
                            createHitEffect(player.x + player.width/2, player.y + player.height/2);
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // Check magic blast collisions
            for (let i = magicBlasts.length - 1; i >= 0; i--) {
                const blast = magicBlasts[i];

                // Check collision with all players except owner
                for (const player of players) {
                    if (player !== blast.owner && player.health > 0) {
                        if (blast.x < player.x + player.width &&
                            blast.x + blast.width > player.x &&
                            blast.y < player.y + player.height &&
                            blast.y + blast.height > player.y) {

                            // For earth spikes, don't remove immediately - let animation finish
                            if (blast.type !== 'earth') {
                                player.takeDamage(blast.damage);

                                // Apply magic effects
                                if (blast.type === 'ice') {
                                    player.slowed = true;
                                    player.slowTimer = 100; // Slow for ~1.5 seconds
                                } else if (blast.type === 'fire') {
                                    player.burning = true;
                                    player.burnTimer = 150; // Burn for ~2.5 seconds
                                    player.burnDamageTimer = 0;
                                }

                                createHitEffect(player.x + player.width/2, player.y + player.height/2);
                                magicBlasts.splice(i, 1);
                            } else {
                                // Earth spike - damage once but keep animating
                                if (!blast.hasHit) {
                                    player.takeDamage(blast.damage);
                                    createHitEffect(player.x + player.width/2, player.y + player.height/2);
                                    blast.hasHit = true; // Mark as hit to prevent multiple damage
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }

        function checkProjectileHit(proj, player) {
            return proj.x < player.x + player.width &&
                   proj.x + proj.width > player.x &&
                   proj.y < player.y + player.height &&
                   proj.y + proj.height > player.y;
        }
        
        function checkPlayerCollision() {
            const players = [player1, player2];
            if (playerCount >= 3 && player3) players.push(player3);
            if (playerCount === 4 && player4) players.push(player4);

            // Check collisions between all pairs of players
            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const p1 = players[i];
                    const p2 = players[j];

                    if (p1.x < p2.x + p2.width &&
                        p1.x + p1.width > p2.x &&
                        p1.y < p2.y + p2.height &&
                        p1.y + p1.height > p2.y) {

                        // Calculate overlap and push players apart
                        const overlap = (p1.x + p1.width/2 < p2.x + p2.width/2) ?
                            (p1.x + p1.width) - p2.x :
                            (p2.x + p2.width) - p1.x;

                        const pushDistance = overlap / 2;

                        if (p1.x + p1.width/2 < p2.x + p2.width/2) {
                            // p1 is on the left
                            p1.x -= pushDistance;
                            p2.x += pushDistance;
                            p1.velocityX -= 2;
                            p2.velocityX += 2;
                        } else {
                            // p1 is on the right
                            p1.x += pushDistance;
                            p2.x -= pushDistance;
                            p1.velocityX += 2;
                            p2.velocityX -= 2;
                        }
                    }
                }
            }
        }

        function checkHit(hitbox, player) {
            if (!hitbox) return false;
            return hitbox.x < player.x + player.width &&
                   hitbox.x + hitbox.width > player.x &&
                   hitbox.y < player.y + player.height &&
                   hitbox.y + hitbox.height > player.y;
        }

        function updateHealthBars() {
            document.getElementById('health1').style.width = `${(player1.health / player1.maxHealth) * 100}%`;
            document.getElementById('health2').style.width = `${(player2.health / player2.maxHealth) * 100}%`;
            if (playerCount >= 3 && player3) {
                document.getElementById('health3').style.width = `${(player3.health / player3.maxHealth) * 100}%`;
            }
            if (playerCount === 4 && player4) {
                document.getElementById('health4').style.width = `${(player4.health / player4.maxHealth) * 100}%`;
            }
        }

        function checkGameOver() {
            const alivePlayers = [];
            if (player1.health > 0) alivePlayers.push('Player 1');
            if (player2.health > 0) alivePlayers.push('Player 2');
            if (playerCount >= 3 && player3 && player3.health > 0) alivePlayers.push('Player 3');
            if (playerCount === 4 && player4 && player4.health > 0) alivePlayers.push('Player 4 (AI)');

            if (alivePlayers.length <= 1) {
                gameRunning = false;
                const winner = alivePlayers.length === 1 ? alivePlayers[0] : 'No one';
                document.getElementById('winnerText').textContent = `${winner} Wins!`;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function selectPlayerCount(count) {
            humanPlayerCount = count;
            playerCount = count;
            playerColors = [];
            document.getElementById('playerSelection').style.display = 'none';

            if (count === 1) {
                // 1 player always needs AI
                hasAI = true;
                playerCount = 2;
                document.getElementById('colorSelection').style.display = 'block';
            } else {
                // 2 or 3 players - ask about AI
                document.getElementById('aiSelection').style.display = 'block';
            }
        }

        function addAI(wantAI) {
            hasAI = wantAI;
            if (hasAI) {
                playerCount = humanPlayerCount + 1;
            } else {
                playerCount = humanPlayerCount;
            }
            document.getElementById('aiSelection').style.display = 'none';
            document.getElementById('colorSelection').style.display = 'block';
        }

        function selectColor(color) {
            playerColors.push(color);

            // Check if we need more color selections
            if (playerColors.length < humanPlayerCount) {
                // Update the prompt for next player
                document.querySelector('#colorSelection h3').textContent = `Player ${playerColors.length + 1} - Choose Your Color:`;
                // Hide the selected color option
                document.querySelectorAll('.color-option').forEach(option => {
                    const colorName = option.getAttribute('onclick').match(/'([^']+)'/)[1];
                    if (playerColors.includes(colorName)) {
                        option.style.opacity = '0.3';
                        option.style.pointerEvents = 'none';
                    }
                });
            } else {
                // All players have selected colors
                document.getElementById('colorSelection').style.display = 'none';
                document.getElementById('mapSelection').style.display = 'block';
                setupPlayers();
            }
        }

        function setupPlayers() {
            // Reset all players beyond player 1 and 2
            player3 = null;
            player4 = null;

            // Reconfigure player 1 with selected color
            player1.color = colorMap[playerColors[0]].color;
            player1.magicElement = colorMap[playerColors[0]].magic;

            // Setup based on configuration
            if (humanPlayerCount === 1) {
                // 1 human vs AI - player 2 is AI
                player2.isAI = true;
                // Clear controls for AI
                player2.controls = {
                    jump: '',
                    left: '',
                    right: '',
                    attack: '',
                    switchWeapon: '',
                    bow: ''
                };
                // AI gets a random color from remaining options
                const aiColors = ['red', 'blue', 'green', 'brown'].filter(c => !playerColors.includes(c));
                const aiColor = aiColors[Math.floor(Math.random() * aiColors.length)];
                player2.color = colorMap[aiColor].color;
                player2.magicElement = colorMap[aiColor].magic;
            } else if (humanPlayerCount === 2) {
                // Player 2 is human with selected color
                player2.isAI = false;
                // Restore player 2 controls
                player2.controls = {
                    jump: 'ArrowUp',
                    left: 'ArrowLeft',
                    right: 'ArrowRight',
                    attack: 'ArrowDown',
                    switchWeapon: '/',
                    bow: '.'
                };
                player2.color = colorMap[playerColors[1]].color;
                player2.magicElement = colorMap[playerColors[1]].magic;

                if (hasAI) {
                    // Add AI as player 3
                    const aiColors = ['red', 'blue', 'green', 'brown'].filter(c => !playerColors.includes(c));
                    const aiColor = aiColors[Math.floor(Math.random() * aiColors.length)];
                    player3 = new Player(500, colorMap[aiColor].color, {
                        jump: '',
                        left: '',
                        right: '',
                        attack: '',
                        switchWeapon: '',
                        bow: ''
                    });
                    player3.isAI = true;
                    player3.magicElement = colorMap[aiColor].magic;
                }
            } else if (humanPlayerCount === 3) {
                // Player 2 is human with selected color
                player2.isAI = false;
                player2.color = colorMap[playerColors[1]].color;
                player2.magicElement = colorMap[playerColors[1]].magic;

                // Player 3 is human with selected color
                player3 = new Player(500, colorMap[playerColors[2]].color, {
                    jump: 'i',
                    left: 'j',
                    right: 'l',
                    attack: 'k',
                    switchWeapon: 'u',
                    bow: 'o'
                });
                player3.isAI = false;
                player3.magicElement = colorMap[playerColors[2]].magic;

                if (hasAI) {
                    // Add AI as player 4
                    const aiColors = ['red', 'blue', 'green', 'brown'].filter(c => !playerColors.includes(c));
                    const aiColor = aiColors[Math.floor(Math.random() * aiColors.length)];
                    player4 = new Player(700, colorMap[aiColor].color, {
                        jump: '',
                        left: '',
                        right: '',
                        attack: '',
                        switchWeapon: '',
                        bow: ''
                    });
                    player4.isAI = true;
                    player4.magicElement = colorMap[aiColor].magic;
                }
            }
        }

        function selectMap(mapName) {
            currentMap = mapName;
            document.querySelectorAll('.map-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.getElementById('map-' + mapName).classList.add('selected');
        }
        
        function startGame() {
            // Hide menu, show game
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            // Show/hide UI elements based on players
            // Update player 1 display
            const getColorName = (color) => {
                for (let [name, data] of Object.entries(colorMap)) {
                    if (data.color === color) return name.charAt(0).toUpperCase() + name.slice(1);
                }
                return 'Player';
            };

            const getColorClass = (color) => {
                for (let [name, data] of Object.entries(colorMap)) {
                    if (data.color === color) {
                        if (name === 'red') return 'rgba(220, 20, 60, 0.3)';
                        if (name === 'blue') return 'rgba(0, 0, 255, 0.3)';
                        if (name === 'green') return 'rgba(0, 255, 0, 0.3)';
                        if (name === 'brown') return 'rgba(101, 67, 33, 0.5)';
                    }
                }
                return 'rgba(128, 128, 128, 0.3)';
            };

            // Update player 1
            document.getElementById('player1').innerHTML = getColorName(player1.color) + (player1.isAI ? ' (AI)' : '');
            document.querySelector('.player1').style.background = getColorClass(player1.color);

            // Player 2 info (always shown)
            if (player2.isAI) {
                document.getElementById('player2').innerHTML = getColorName(player2.color) + ' (AI)';
            } else {
                document.getElementById('player2').innerHTML = getColorName(player2.color);
            }
            document.querySelector('.player2').style.background = getColorClass(player2.color);

            // Player 3
            if (player3) {
                document.getElementById('player3Info').style.display = 'block';
                document.querySelector('.player3').style.background = getColorClass(player3.color);
                if (player3.isAI) {
                    document.getElementById('player3Controls').style.display = 'none';
                    document.getElementById('player3').innerHTML = getColorName(player3.color) + ' (AI)';
                } else {
                    document.getElementById('player3Controls').style.display = 'block';
                    document.getElementById('player3').innerHTML = getColorName(player3.color);
                }
            } else {
                document.getElementById('player3Info').style.display = 'none';
                document.getElementById('player3Controls').style.display = 'none';
            }

            // Player 4
            if (player4) {
                document.getElementById('player4Info').style.display = 'block';
                document.querySelector('.player4').style.background = getColorClass(player4.color);
                if (player4.isAI) {
                    document.getElementById('player4Controls').style.display = 'none';
                    document.getElementById('player4').innerHTML = getColorName(player4.color) + ' (AI)';
                } else {
                    document.getElementById('player4Controls').style.display = 'block';
                    document.getElementById('player4').innerHTML = getColorName(player4.color);
                }
            } else {
                document.getElementById('player4Info').style.display = 'none';
                document.getElementById('player4Controls').style.display = 'none';
            }

            // Initialize map
            platforms = [];
            if (currentMap === 'platform') {
                platforms.push(new Platform(canvas.width/2 - 100, groundY - 150, 200, 20));
            } else if (currentMap === 'skylands') {
                // Create cloud platforms
                platforms.push(new Platform(100, 250, 150, 20, true));
                platforms.push(new Platform(300, 150, 120, 20, true));
                platforms.push(new Platform(500, 200, 150, 20, true));
                platforms.push(new Platform(750, 250, 150, 20, true));
                platforms.push(new Platform(400, 350, 200, 20, true));
                // Keep ground as a safety net
            }

            // Reset players
            player1.health = player1.maxHealth;
            player2.health = player2.maxHealth;
            player1.x = playerCount === 3 ? 150 : 200;
            player2.x = playerCount === 3 ? 850 : 800;
            player1.y = groundY - 100;
            player2.y = groundY - 100;
            player1.velocityX = 0;
            player1.velocityY = 0;
            player2.velocityX = 0;
            player2.velocityY = 0;
            player1.stunned = false;
            player2.stunned = false;
            player1.attacking = false;
            player2.attacking = false;
            player1.attackAngle = 0;
            player2.attackAngle = 0;
            player1.hitConfirmed = false;
            player2.hitConfirmed = false;

            // Reset player 3 if active
            if (playerCount >= 3 && player3) {
                player3.health = player3.maxHealth;
                player3.x = playerCount === 4 ? 300 : 500;
                player3.y = groundY - 100;
                player3.velocityX = 0;
                player3.velocityY = 0;
                player3.stunned = false;
                player3.attacking = false;
                player3.attackAngle = 0;
                player3.hitConfirmed = false;
            }

            // Reset player 4 if active
            if (playerCount === 4 && player4) {
                player4.health = player4.maxHealth;
                player4.x = 700;
                player4.y = groundY - 100;
                player4.velocityX = 0;
                player4.velocityY = 0;
                player4.stunned = false;
                player4.attacking = false;
                player4.attackAngle = 0;
                player4.hitConfirmed = false;
            }
            
            // Clear projectiles, magic and effects
            projectiles.length = 0;
            magicBlasts.length = 0;
            hitEffects.length = 0;
            
            gameRunning = true;
            updateHealthBars();
            
            // Start game loop if not already running
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                gameLoop();
            }
        }
        
        function backToMenu() {
            gameRunning = false;
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            // Reset to player selection
            document.getElementById('playerSelection').style.display = 'block';
            document.getElementById('mapSelection').style.display = 'none';
            document.getElementById('aiSelection').style.display = 'none';
            document.getElementById('colorSelection').style.display = 'none';
            // Reset color selections
            playerColors = [];
            document.querySelectorAll('.color-option').forEach(option => {
                option.style.opacity = '1';
                option.style.pointerEvents = 'auto';
            });
            document.querySelector('#colorSelection h3').textContent = 'Choose Your Color:';
        }
        
        function restartGame() {
            player1.health = player1.maxHealth;
            player2.health = player2.maxHealth;
            player1.x = playerCount === 3 ? 150 : 200;
            player2.x = playerCount === 3 ? 850 : 800;
            player1.y = groundY - 100;
            player2.y = groundY - 100;
            player1.velocityX = 0;
            player1.velocityY = 0;
            player2.velocityX = 0;
            player2.velocityY = 0;
            player1.stunned = false;
            player2.stunned = false;
            player1.attacking = false;
            player2.attacking = false;
            player1.attackAngle = 0;
            player2.attackAngle = 0;
            player1.hitConfirmed = false;
            player2.hitConfirmed = false;

            // Reset player 3 if active
            if (playerCount >= 3 && player3) {
                player3.health = player3.maxHealth;
                player3.x = playerCount === 4 ? 300 : 500;
                player3.y = groundY - 100;
                player3.velocityX = 0;
                player3.velocityY = 0;
                player3.stunned = false;
                player3.attacking = false;
                player3.attackAngle = 0;
                player3.hitConfirmed = false;
            }

            // Reset player 4 if active
            if (playerCount === 4 && player4) {
                player4.health = player4.maxHealth;
                player4.x = 700;
                player4.y = groundY - 100;
                player4.velocityX = 0;
                player4.velocityY = 0;
                player4.stunned = false;
                player4.attacking = false;
                player4.attackAngle = 0;
                player4.hitConfirmed = false;
            }
            
            // Clear projectiles, magic and effects
            projectiles.length = 0;
            magicBlasts.length = 0;
            hitEffects.length = 0;
            
            gameRunning = true;
            document.getElementById('gameOver').style.display = 'none';
            updateHealthBars();
        }

        function drawBackground() {
            // Sky gradient is handled by canvas CSS
            
            // Draw ground
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            // Draw grass
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, groundY, canvas.width, 5);
            
            // Draw some static clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(150, 80, 25, 0, Math.PI * 2);
            ctx.arc(180, 85, 30, 0, Math.PI * 2);
            ctx.arc(210, 80, 25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(750, 100, 20, 0, Math.PI * 2);
            ctx.arc(775, 105, 25, 0, Math.PI * 2);
            ctx.arc(800, 100, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw platforms
            platforms.forEach(platform => platform.draw());
        }

        function gameLoop() {
            if (!gameRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake for earthquake
            if (screenShake > 0) {
                ctx.save();
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
                screenShake *= 0.95; // Decay shake
                if (screenShake < 0.1) screenShake = 0;
            }

            // Draw background
            drawBackground();

            // Draw earthquake effect
            if (earthquakeActive) {
                // Ground cracks effect
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const x = (canvas.width / 5) * i + Math.sin(earthquakeTimer * 0.3 + i) * 20;
                    ctx.beginPath();
                    ctx.moveTo(x, groundY);
                    ctx.lineTo(x + 20, groundY + 30);
                    ctx.lineTo(x + 10, groundY + 50);
                    ctx.stroke();
                }

                // Dust clouds
                ctx.fillStyle = `rgba(139, 90, 43, ${0.3 * (earthquakeTimer / 90)})`;
                for (let i = 0; i < canvas.width; i += 50) {
                    const y = groundY - Math.abs(Math.sin(earthquakeTimer * 0.2 + i * 0.01)) * 20;
                    ctx.beginPath();
                    ctx.arc(i, y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Handle input
            handleInput();

            // Update AI only if there's been recent human input (within last 500ms)
            // This prevents AI from running when no humans are playing
            if (Date.now() - lastInputTime < 500) {
                updateAI();
            }

            // Update players
            player1.update();
            player2.update();
            if (playerCount >= 3 && player3) {
                player3.update();
            }
            if (playerCount === 4 && player4) {
                player4.update();
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update();
                if (!projectiles[i].active) {
                    projectiles.splice(i, 1);
                }
            }

            // Update magic blasts
            for (let i = magicBlasts.length - 1; i >= 0; i--) {
                magicBlasts[i].update();
                if (!magicBlasts[i].active) {
                    magicBlasts.splice(i, 1);
                }
            }
            
            // Update hit effects
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                hitEffects[i].update();
                if (!hitEffects[i].active) {
                    hitEffects.splice(i, 1);
                }
            }

            // Update earthquake
            if (earthquakeActive) {
                earthquakeTimer--;

                // Damage grounded players every 20 frames
                if (earthquakeTimer % 20 === 0) {
                    const players = [player1, player2];
                    if (player3) players.push(player3);
                    if (player4) players.push(player4);

                    for (const player of players) {
                        // Skip the caster and dead players
                        if (player === earthquakeCaster || player.health <= 0) continue;

                        // Only damage if on ground (not jumping or on platform)
                        if (player.onGround && player.y >= groundY - player.height - 5) {
                            player.takeDamage(8, true); // 8 damage per tick
                            createHitEffect(player.x + player.width/2, player.y + player.height);
                            // Small upward knock
                            player.velocityY = -3;
                        }
                    }
                }

                if (earthquakeTimer <= 0) {
                    earthquakeActive = false;
                    earthquakeCaster = null;
                }
            }

            // Check collisions
            checkCollisions();
            checkPlayerCollision();

            // Draw players
            player1.draw();
            player2.draw();
            if (playerCount >= 3 && player3) {
                player3.draw();
            }
            if (playerCount === 4 && player4) {
                player4.draw();
            }

            // Draw targeting indicators
            if (player1.isAiming) {
                const target = playerCount === 3 ? getNearestTarget(player1) : player2;
                drawTargetingLine(player1, target);
            }
            if (player2.isAiming) {
                const target = playerCount === 3 ? getNearestTarget(player2) : player1;
                drawTargetingLine(player2, target);
            }
            if (playerCount >= 3 && player3 && player3.isAiming) {
                const target = getNearestTarget(player3);
                drawTargetingLine(player3, target);
            }
            if (playerCount === 4 && player4 && player4.isAiming) {
                const target = getNearestTarget(player4);
                drawTargetingLine(player4, target);
            }
            
            // Draw projectiles
            projectiles.forEach(proj => proj.draw());

            // Draw magic blasts
            magicBlasts.forEach(blast => blast.draw());
            
            // Draw hit effects
            hitEffects.forEach(effect => effect.draw());

            // Update UI
            updateHealthBars();
            checkGameOver();

            // Restore canvas if shaking
            if (screenShake > 0) {
                ctx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // Game loop running flag
        let gameLoopRunning = false;
        
        // Initialize health bars
        updateHealthBars();
    </script>
</body>
</html>